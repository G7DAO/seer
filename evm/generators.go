// - [ ] Working CLI generation for deployment, calls, transactions against a contract given its ABI and bytecode.
// - [ ] Generated code has a header comment explaining that code is generated by seer, modify at your own risk, etc.
// - [ ] Generated CLI contains a command to crawl and parse contract events.

package evm

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/iancoleman/strcase"
)

var ErrParsingCLIParams error = errors.New("error parsing CLI parameters")

// GenerateTypes generates Go bindings to an Ethereum contract ABI (or union of such). This functionality
// is roughly equivalent to that provided by the `abigen` tool provided by go-ethereum:
// https://github.com/ethereum/go-ethereum/tree/master/cmd/abigen
// Under the hood, GenerateTypes uses the Bind method implemented in go-ethereum in a manner similar to
// abigen. It just offers a simpler call signature that makes more sense for users of seer.
//
// Arguments:
//  1. structName: The name of the generated Go struct that will represent this contract.
//  2. abi: The bytes representing the contract's ABI.
//  3. bytecode: The bytes representing the contract's bytecode. If this is provided, a "deploy" method
//     will be generated. If it is not provided, no such method will be generated.
//  4. packageName: If this is provided, the generated code will contain a package declaration of this name.
func GenerateTypes(structName string, abi []byte, bytecode []byte, packageName string) (string, error) {
	return bind.Bind([]string{structName}, []string{string(abi)}, []string{string(bytecode)}, []map[string]string{}, packageName, bind.LangGo, map[string]string{}, map[string]string{})
}

type MethodArgument struct {
	Name                    string
	ArgumentType            ast.Expr
	InnerArgumentTypeString string
	CLIVar                  string
	CLIName                 string
	CLIType                 string
	PFlagHandler            string
	Container               bool
}

type MethodReturnValue struct {
	ReturnType string
}

type HandlerDefinition struct {
	MethodName    string
	HandlerName   string
	MethodArgs    []MethodArgument
	MethodReturns []MethodReturnValue
}

// Data structure that parametrizes CLI generation.
type CLIParams struct {
	StructName       string
	DeployHandler    HandlerDefinition
	ViewHandlers     []HandlerDefinition
	TransactHandlers []HandlerDefinition
}

// // This handles types which can be output by bind.bindBasicTypeGo:
// // https://github.com/ethereum/go-ethereum/blob/eaac53ec383342fa6ef9c333659d40f7c5dac108/accounts/abi/bind/bind.go#L312
// func CLITypeForBasicType(basicType string) string {
// 	if basicType == "uint8" || basicType == "uint16" || basicType == "uint32" || basicType == "uint64" || basicType == "int8" || basicType == "int16" || basicType == "int32" || basicType == "int64" {
// 		return basicType
// 	} else if strings.HasSuffix(basicType, "]byte") {
// 		return "[]byte"
// 	}
// 	return "string"
// }

func ParseMethodArguments(method *ast.FuncDecl) ([]MethodArgument, error) {
	result := make([]MethodArgument, len(method.Type.Params.List))
	for i, param := range method.Type.Params.List {
		if len(param.Names) != 1 {
			return result, ErrParsingCLIParams
		}
		result[i].Name = param.Names[0].Name
		result[i].ArgumentType = param.Type
	}
	return result, nil
}

func ParseCLIParams(structName string, deployMethod *ast.FuncDecl, viewMethods map[string]*ast.FuncDecl, transactMethods map[string]*ast.FuncDecl) (CLIParams, error) {
	result := CLIParams{StructName: structName}

	tempFileset := token.NewFileSet()

	result.DeployHandler = HandlerDefinition{
		MethodName:  deployMethod.Name.Name,
		HandlerName: fmt.Sprintf("Create%sDeploymentCommand", structName),
	}
	// Deploy methods always take the following two arguments at the beginning of their argument list:
	// - auth *bind.TransactOpts
	// - backend bind.ContractBackend
	// We ignore these arguments here because they can all be handled uniformly when we run codegen for the
	// deployment command.
	if len(deployMethod.Type.Params.List) < 2 {
		return result, ErrParsingCLIParams
	}
	result.DeployHandler.MethodArgs = make([]MethodArgument, len(deployMethod.Type.Params.List)-2)
	for i := 0; i < len(deployMethod.Type.Params.List)-2; i++ {
		methodArg := MethodArgument{
			Name:         deployMethod.Type.Params.List[i+2].Names[0].Name,
			ArgumentType: deployMethod.Type.Params.List[i+2].Type,
		}

		var b bytes.Buffer

		switch methodArg.ArgumentType.(type) {
		case *ast.ArrayType:
			printer.Fprint(&b, tempFileset, methodArg.ArgumentType.(*ast.ArrayType).Elt)
			methodArg.Container = true
			methodArg.InnerArgumentTypeString = b.String()
		default:
			printer.Fprint(&b, tempFileset, methodArg.ArgumentType)
			methodArg.InnerArgumentTypeString = b.String()
		}

		methodArg.CLIName = strcase.ToKebab(methodArg.Name)

		switch methodArg.InnerArgumentTypeString {
		case "common.Address":
			methodArg.CLIType = "string"
			methodArg.PFlagHandler = "StringVar"
		case "*big.Int":

		}

		fmt.Printf("\t%v\n", methodArg)

		methodArg.CLIVar = fmt.Sprintf("%sRaw", methodArg.Name)
	}

	return result, nil
}

// AddCLI adds CLI code (using github.com/spf13/cobra command-line framework) for code generated by the
// GenerateTypes function. The output of this function *contains* the input, with enrichments (some of
// then inline). It should not be concatenated with the output of GenerateTypes, but rather be used as
// part of a chain.
func AddCLI(sourceCode, structName string) (string, error) {
	fileset := token.NewFileSet()
	filename := ""
	sourceAST, sourceASTErr := parser.ParseFile(fileset, filename, sourceCode, parser.ParseComments)
	if sourceASTErr != nil {
		return "", sourceASTErr
	}

	deployer := fmt.Sprintf("Deploy%s", structName)
	callerReceiver := fmt.Sprintf("%sCallerSession", structName)
	transactorReceiver := fmt.Sprintf("%sTransactorSession", structName)

	var deployMethod *ast.FuncDecl
	structViewMethods := map[string]*ast.FuncDecl{}
	structTransactionMethods := map[string]*ast.FuncDecl{}

	ast.Inspect(sourceAST, func(node ast.Node) bool {
		switch t := node.(type) {
		case *ast.GenDecl:
			// Add additional imports:
			// - os
			// - github.com/spf13/cobra
			if t.Tok == token.IMPORT {
				t.Specs = append(t.Specs, &ast.ImportSpec{Path: &ast.BasicLit{Value: `"os"`}}, &ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/spf13/cobra"`}})
			}
			return true
		case *ast.FuncDecl:
			if t.Recv != nil {
				receiverName := t.Recv.List[0].Type.(*ast.StarExpr).X.(*ast.Ident).Name
				if receiverName == callerReceiver {
					structViewMethods[t.Name.Name] = t
				} else if receiverName == transactorReceiver {
					structTransactionMethods[t.Name.Name] = t
				}
			} else {
				if t.Name.Name == deployer {
					deployMethod = t
				}
			}
			return false
		default:
			return true
		}
	})

	var codeBytes bytes.Buffer
	printer.Fprint(&codeBytes, fileset, sourceAST)
	code := codeBytes.String()

	templateFuncs := map[string]any{
		"KebabCase":      strcase.ToKebab,
		"ScreamingSnake": strcase.ToScreamingSnake,
	}

	cliTemplate, cliTemplateParseErr := template.New("cli").Funcs(templateFuncs).Parse(CLICodeTemplate)
	if cliTemplateParseErr != nil {
		return code, cliTemplateParseErr
	}

	fmt.Println("PARAKEET")
	params, paramsErr := ParseCLIParams(structName, deployMethod, structViewMethods, structTransactionMethods)
	if paramsErr != nil {
		return code, paramsErr
	}

	var b bytes.Buffer
	templateErr := cliTemplate.Execute(&b, params)
	if templateErr != nil {
		return code, templateErr
	}

	return code + "\n\n" + b.String(), nil
}

var CLICodeTemplate string = `
var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the {{(ScreamingSnake .StructName)}}_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the {{(ScreamingSnake .StructName)}}_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("{{(ScreamingSnake .StructName)}}_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func Create{{.StructName}}Command() *cobra.Command {
	cmd := &cobra.Command{
		Use:  "{{(KebabCase .StructName)}}",
		Short: "Interact with the {{.StructName}} contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(DeployGroup, ViewGroup, TransactGroup)

	return cmd
}
`

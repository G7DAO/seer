// - [ ] Working CLI generation for deployment, calls, transactions against a contract given its ABI and bytecode.
// - [ ] Generated code has a header comment explaining that code is generated by seer, modify at your own risk, etc.
// - [ ] Generated CLI contains a command to crawl and parse contract events.

package evm

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"strconv"
	"strings"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/iancoleman/strcase"
	"golang.org/x/tools/imports"
)

var ErrParsingCLIParams error = errors.New("error parsing CLI parameters")
var ErrUnrecognizedType error = errors.New("unrecognized type")
var ErrParameterUnnamed error = errors.New("parameter is unnamed")

// GenerateTypes generates Go bindings to an Ethereum contract ABI (or union of such). This functionality
// is roughly equivalent to that provided by the `abigen` tool provided by go-ethereum:
// https://github.com/ethereum/go-ethereum/tree/master/cmd/abigen
// Under the hood, GenerateTypes uses the Bind method implemented in go-ethereum in a manner similar to
// abigen. It just offers a simpler call signature that makes more sense for users of seer.
//
// Arguments:
//  1. structName: The name of the generated Go struct that will represent this contract.
//  2. abi: The bytes representing the contract's ABI.
//  3. bytecode: The bytes representing the contract's bytecode. If this is provided, a "deploy" method
//     will be generated. If it is not provided, no such method will be generated.
//  4. packageName: If this is provided, the generated code will contain a package declaration of this name.
func GenerateTypes(structName string, abi []byte, bytecode []byte, packageName string) (string, error) {
	return bind.Bind([]string{structName}, []string{string(abi)}, []string{string(bytecode)}, []map[string]string{}, packageName, bind.LangGo, map[string]string{}, map[string]string{})
}

// ABIBoundParameter represents a Go type that is bound to an Ethereum contract ABI item.
// The different types of types we need to deal with (based on https://github.com/ethereum/go-ethereum/blob/47d76c5f9508d3594bfc9aafa95c04edae71c5a1/accounts/abi/bind/bind.go#L338):
// - uint8
// - uint16
// - uint32
// - uint64
// - int8
// - int16
// - int32
// - int64
// - *big.Int
// - [n]byte
// - []byte
// - string
// - bool
// - array
// - struct
type ABIBoundParameter struct {
	Name     string
	GoType   string
	Node     ast.Node
	IsArray  bool
	Length   int
	Subtypes []ABIBoundParameter
}

type MethodArgument struct {
	Argument   ABIBoundParameter
	CLIVar     string
	CLIRawVar  string
	CLIName    string
	CLIType    string
	CLIRawType string
	Flag       string
	PreRunE    string
}

type HandlerDefinition struct {
	MethodName    string
	HandlerName   string
	MethodArgs    []MethodArgument
	MethodReturns []ABIBoundParameter
}

// Data structure that parametrizes CLI generation.
type CLISpecification struct {
	StructName       string
	DeployHandler    HandlerDefinition
	ViewHandlers     []HandlerDefinition
	TransactHandlers []HandlerDefinition
}

// ParseBoundParameter parses an ast.Node representing a method parameter (or return value). It inspects
// the ast.Node recursively to determine the information needed to parse that node to the user from command-line
// input or to present an instance of that type to a user as command output.
func ParseBoundParameter(arg ast.Node) (ABIBoundParameter, error) {
	result := ABIBoundParameter{Node: arg}

	switch n := arg.(type) {

	// Entrypoint of recursion - highest level of abstraction and we'll never see a field again in subsequent
	// invocations.
	case *ast.Field:
		if len(n.Names) > 0 {
			result.Name = n.Names[0].Name
		}
		subresult, subresultErr := ParseBoundParameter(n.Type)
		if subresultErr != nil {
			return subresult, subresultErr
		}
		result.GoType = subresult.GoType
		result.IsArray = subresult.IsArray
		result.Length = subresult.Length
		result.Subtypes = subresult.Subtypes

	case *ast.ArrayType:
		result.IsArray = true

		// Check if the array is of fixed length. If so, extract the length into the result.Length field.
		switch t1 := n.Elt.(type) {
		case *ast.ArrayType:
			if t1.Len != nil {
				var conversionErr error
				result.Length, conversionErr = strconv.Atoi(t1.Len.(*ast.BasicLit).Value)
				if conversionErr != nil {
					return result, conversionErr
				}
			}
		}

		// Set result.Subtypes to be the type of the array elements.
		result.Subtypes = make([]ABIBoundParameter, 1)
		subtype, subtypeErr := ParseBoundParameter(n.Elt)
		if subtypeErr != nil {
			return result, subtypeErr
		}
		result.Subtypes[0] = subtype

		result.GoType = fmt.Sprintf("[]%s", subtype.GoType)

	default:
		var b bytes.Buffer
		printer.Fprint(&b, token.NewFileSet(), n)
		result.GoType = b.String()
	}

	return result, nil
}

// Fills in the information required to represent the given parameters as command-line argument. Takes
// an array of ABIBoundParameter structs because it deduplicates flags.
// This is where we map the Go types used in the methods to the Go types used to parse those arguments from the
// command line.
func DeriveMethodArguments(parameters []ABIBoundParameter) ([]MethodArgument, error) {
	result := make([]MethodArgument, len(parameters))

	// assignedNames helps us ensure that there are no collisions in named arguments in our CLI.
	// It contains reserved argument names and is populated with the name of every argument that gets added
	// to a method's CLI.
	assignedNames := map[string]bool{
		"rpc":                  true,
		"keystore":             true,
		"value":                true,
		"gasPrice":             true,
		"nonce":                true,
		"from":                 true,
		"fromAddress":          true,
		"to":                   true,
		"toAddress":            true,
		"block":                true,
		"pending":              true,
		"maxFeePerGas":         true,
		"maxPriorityFeePerGas": true,
		"gasLimit":             true,
		"noSend":               true,
		"timeout":              true,
		"password":             true,
		"contract":             true,
		"method":               true,
		"args":                 true,
		"output":               true,
		"chainId":              true,
		"network":              true,
		"simulate":             true,
	}

	for i, parameter := range parameters {
		result[i].Argument = parameter

		if parameter.Name == "" {
			return result, ErrParameterUnnamed
		}
		j := 0
		name := strings.Trim(parameter.Name, "-_")
		for {
			_, assigned := assignedNames[name]
			if !assigned {
				break
			}
			name = fmt.Sprintf("%s%d", parameter.Name, j)
			j++
		}
		assignedNames[name] = true

		result[i].CLIVar = name
		// If CLIRawVar is different from CLIVar, that is a signal that we need to add parsing logic in
		// PreRunE.
		result[i].CLIRawVar = name
		result[i].CLIType = parameter.GoType
		result[i].CLIRawType = parameter.GoType
		result[i].CLIName = strcase.ToKebab(name)

		// Cases we need to handle
		// - uint8
		// - uint16
		// - uint32
		// - uint64
		// - int8
		// - int16
		// - int32
		// - int64
		// - common.Address
		// - *big.Int
		// - anything else (structs, arrays, etc. will be parsed as JSON strings or strings of the form "@<filename>" containing JSON)
		switch parameter.GoType {
		case "uint8":
			result[i].Flag = fmt.Sprintf("Uint8Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "uint16":
			result[i].Flag = fmt.Sprintf("Uint16Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "uint32":
			result[i].Flag = fmt.Sprintf("Uint32Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "uint64":
			result[i].Flag = fmt.Sprintf("Uint64Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int8":
			result[i].Flag = fmt.Sprintf("Int8Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int16":
			result[i].Flag = fmt.Sprintf("Int16Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int32":
			result[i].Flag = fmt.Sprintf("Int32Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int64":
			result[i].Flag = fmt.Sprintf("Int64Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "string":
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)

		case "*big.Int":
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
			preRunEFormat := `
if %s == "" {
	return fmt.Errorf("--%s argument not specified")
}
%s = new(big.Int)
%s.SetString(%s, 0)
`
			result[i].PreRunE = fmt.Sprintf(
				preRunEFormat,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIVar,
				result[i].CLIVar,
				result[i].CLIRawVar,
			)

		case "common.Address":
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
			preRunEFormat := `
if %s == "" {
	return fmt.Errorf("--%s argument not specified")
} else if !common.IsHexAddress(%s) {
	return fmt.Errorf("--%s argument is not a valid Ethereum address")
}
%s = common.HexToAddress(%s)
`
			result[i].PreRunE = fmt.Sprintf(
				preRunEFormat,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIVar,
				result[i].CLIRawVar,
			)

		// In this case, we parse as JSON either directly from the command line or through a file if the argument as an "@" prefix (like curl)
		default:
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
			preRunEFormat := `
if %s == "" {
	return fmt.Errorf("--%s argument not specified")
} else if strings.HasPrefix(%s, "@") {
	// TODO: Load JSON object from file
} else {
	// TODO: Load JSON object from string
}
`

			result[i].PreRunE = fmt.Sprintf(
				preRunEFormat,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIRawVar,
			)
		}
	}

	return result, nil
}

func ParseCLIParams(structName string, deployMethod *ast.FuncDecl, viewMethods map[string]*ast.FuncDecl, transactMethods map[string]*ast.FuncDecl) (CLISpecification, error) {
	result := CLISpecification{StructName: structName}

	result.DeployHandler = HandlerDefinition{
		HandlerName: fmt.Sprintf("Create%sDeploymentCommand", structName),
	}
	if deployMethod != nil {
		result.DeployHandler.MethodName = deployMethod.Name.Name

		// Deploy methods always take the following two arguments at the beginning of their argument list:
		// - auth *bind.TransactOpts
		// - backend bind.ContractBackend
		// We ignore these arguments here because they can all be handled uniformly when we run codegen for the
		// deployment command.
		if len(deployMethod.Type.Params.List) < 2 {
			return result, ErrParsingCLIParams
		}
		parameters := make([]ABIBoundParameter, len(deployMethod.Type.Params.List)-2)
		for i, arg := range deployMethod.Type.Params.List[2:] {
			parameter, parameterErr := ParseBoundParameter(arg)
			if parameterErr != nil {
				return result, parameterErr
			}
			parameters[i] = parameter
		}

		methodArgs, methodArgsErr := DeriveMethodArguments(parameters)
		if methodArgsErr != nil {
			return result, methodArgsErr
		}
		result.DeployHandler.MethodArgs = methodArgs
	}

	result.TransactHandlers = make([]HandlerDefinition, len(transactMethods))
	currentHandler := 0
	for methodName, methodNode := range transactMethods {
		parameters := make([]ABIBoundParameter, len(methodNode.Type.Params.List))
		for i, arg := range methodNode.Type.Params.List {
			parameter, parameterErr := ParseBoundParameter(arg)
			if parameterErr != nil {
				return result, parameterErr
			}
			parameters[i] = parameter
		}

		methodArgs, methodArgsErr := DeriveMethodArguments(parameters)
		if methodArgsErr != nil {
			return result, methodArgsErr
		}

		handler := HandlerDefinition{
			MethodName:  methodName,
			HandlerName: fmt.Sprintf("Create%sCommand", strcase.ToCamel(methodName)),
			MethodArgs:  methodArgs,
		}

		result.TransactHandlers[currentHandler] = handler
		currentHandler++
	}

	return result, nil
}

// AddCLI adds CLI code (using github.com/spf13/cobra command-line framework) for code generated by the
// GenerateTypes function. The output of this function *contains* the input, with enrichments (some of
// then inline). It should not be concatenated with the output of GenerateTypes, but rather be used as
// part of a chain.
func AddCLI(sourceCode, structName string) (string, error) {
	fileset := token.NewFileSet()
	filename := ""
	sourceAST, sourceASTErr := parser.ParseFile(fileset, filename, sourceCode, parser.ParseComments)
	if sourceASTErr != nil {
		return "", sourceASTErr
	}

	deployer := fmt.Sprintf("Deploy%s", structName)
	callerReceiver := fmt.Sprintf("%sCallerSession", structName)
	transactorReceiver := fmt.Sprintf("%sTransactorSession", structName)

	var deployMethod *ast.FuncDecl
	structViewMethods := map[string]*ast.FuncDecl{}
	structTransactionMethods := map[string]*ast.FuncDecl{}

	ast.Inspect(sourceAST, func(node ast.Node) bool {
		switch t := node.(type) {
		case *ast.GenDecl:
			// Add additional imports:
			// - context
			// - encoding/hex
			// - fmt
			// - os
			// - time
			// - github.com/spf13/cobra
			// - github.com/ethereum/go-ethereum/accounts/keystore
			// - github.com/ethereum/go-ethereum/ethclient
			// - golang.org/x/term
			if t.Tok == token.IMPORT {
				t.Specs = append(
					t.Specs,
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"context"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"encoding/hex"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"fmt"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"os"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"time"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/spf13/cobra"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/ethereum/go-ethereum/accounts/keystore"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/ethereum/go-ethereum/ethclient"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"golang.org/x/term"`}},
				)
			}
			return true
		case *ast.FuncDecl:
			if t.Recv != nil {
				receiverName := t.Recv.List[0].Type.(*ast.StarExpr).X.(*ast.Ident).Name
				if receiverName == callerReceiver {
					structViewMethods[t.Name.Name] = t
				} else if receiverName == transactorReceiver {
					structTransactionMethods[t.Name.Name] = t
				}
			} else {
				if t.Name.Name == deployer {
					deployMethod = t
				}
			}
			return false
		default:
			return true
		}
	})

	var codeBytes bytes.Buffer
	printer.Fprint(&codeBytes, fileset, sourceAST)
	code := codeBytes.String()

	templateFuncs := map[string]any{
		"KebabCase":      strcase.ToKebab,
		"ScreamingSnake": strcase.ToScreamingSnake,
	}

	cliTemplate, cliTemplateParseErr := template.New("cli").Funcs(templateFuncs).Parse(CLICodeTemplate)
	if cliTemplateParseErr != nil {
		return code, cliTemplateParseErr
	}

	deployCommandTemplate, deployCommandTemplateErr := template.New("deploy").Funcs(templateFuncs).Parse(DeployCommandTemplate)
	if deployCommandTemplateErr != nil {
		return code, deployCommandTemplateErr
	}

	transactionMethodsCommandTemplate, transactionMethodsCommandTemplateErr := template.New("transactionMethods").Funcs(templateFuncs).Parse(TransactMethodCommandTemplate)
	if transactionMethodsCommandTemplateErr != nil {
		return code, transactionMethodsCommandTemplateErr
	}

	cliSpec, cliSpecErr := ParseCLIParams(structName, deployMethod, structViewMethods, structTransactionMethods)
	if cliSpecErr != nil {
		return code, cliSpecErr
	}

	var b bytes.Buffer

	deployTemplateErr := deployCommandTemplate.Execute(&b, cliSpec)
	if deployTemplateErr != nil {
		return code, deployTemplateErr
	}
	code = code + "\n\n" + b.String()

	b.Reset()
	transactionMethodsTemplateErr := transactionMethodsCommandTemplate.Execute(&b, cliSpec)
	if transactionMethodsTemplateErr != nil {
		return code, transactionMethodsTemplateErr
	}
	code = code + "\n\n" + b.String()

	b.Reset()
	cliTemplateErr := cliTemplate.Execute(&b, cliSpec)
	if cliTemplateErr != nil {
		return code, cliTemplateErr
	}
	code = code + "\n\n" + b.String()

	// We use golang.org/x/tools/imports instead of go/format.
	// imports.Process does what format.Source does AND it removes unused imports.
	opts := &imports.Options{
		Fragment:   false,
		AllErrors:  true,
		Comments:   true,
		FormatOnly: false,
	}
	generatedCode, formattingErr := imports.Process("mem", []byte(code), opts)
	if formattingErr != nil {
		return code, formattingErr
	}

	return string(generatedCode), nil
}

var CLICodeTemplate string = `
var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the {{(ScreamingSnake .StructName)}}_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the {{(ScreamingSnake .StructName)}}_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("{{(ScreamingSnake .StructName)}}_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func Create{{.StructName}}Command() *cobra.Command {
	cmd := &cobra.Command{
		Use:  "{{(KebabCase .StructName)}}",
		Short: "Interact with the {{.StructName}} contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	{{if .DeployHandler.MethodName}}
	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	{{- end}}
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	{{if .DeployHandler.MethodName}}
	cmd{{.DeployHandler.MethodName}} := {{.DeployHandler.HandlerName}}()
	cmd{{.DeployHandler.MethodName}}.GroupID = DeployGroup.ID
	cmd.AddCommand(cmd{{.DeployHandler.MethodName}})
	{{- end}}

	{{range .TransactHandlers}}
	cmdTransact{{.MethodName}} := {{.HandlerName}}()
	cmdTransact{{.MethodName}}.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransact{{.MethodName}})
	{{- end}}

	return cmd
}
`

// This template generates the handler for smart contract deployment. It is intended to be used with a
// HandlerDefinition struct.
var DeployCommandTemplate string = `
{{if .DeployHandler.MethodName}}
func {{.DeployHandler.HandlerName}}() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint

	{{range .DeployHandler.MethodArgs}}
	var {{.CLIVar}} {{.CLIType}}
	{{if (ne .CLIRawVar .CLIVar)}}var {{.CLIRawVar}} {{.CLIRawType}}{{end}}
	{{- end}}

	cmd := &cobra.Command{
		Use:  "deploy",
		Short: "Deploy a new {{.StructName}} contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			{{range .DeployHandler.MethodArgs}}
			{{.PreRunE}}
			{{- end}}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			address, deploymentTransaction, _, deploymentErr := {{.DeployHandler.MethodName}}(
				transactionOpts,
				client,
				{{- range .DeployHandler.MethodArgs}}
				{{.CLIVar}},
				{{- end}}
			)
			if deploymentErr != nil {
				return deploymentErr
			}


			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: 		transactionOpts.From,
					Data: 		deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")

	{{range .DeployHandler.MethodArgs}}
	cmd.Flags().{{.Flag}}
	{{- end}}

	return cmd
}
{{end}}
`

// This template generates the handler for smart contract call methods. It is intended to be used with
// a HandlerDefinition struct.
var ViewMethodCommandTemplate string = `
func {{.HandlerName}}
`

// This template generates the handler for smart contract methods that submit transactions. It is intended
// to be used with a HandlerDefinition struct.
var TransactMethodCommandTemplate string = `{{$structName := .StructName}}
{{range .TransactHandlers}}
func {{.HandlerName}}() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	{{range .MethodArgs}}
	var {{.CLIVar}} {{.CLIType}}
	{{if (ne .CLIRawVar .CLIVar)}}var {{.CLIRawVar}} {{.CLIRawType}}{{end}}
	{{- end}}


	cmd := &cobra.Command{
		Use: "{{(KebabCase .MethodName)}}",
		Short: "Execute the {{.MethodName}} method on a {{$structName}} contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			{{range .MethodArgs}}
			{{.PreRunE}}
			{{- end}}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := New{{$structName}}(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := {{$structName}}TransactorSession{
				Contract: &contract.{{$structName}}Transactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.{{.MethodName}}(
				{{- range .MethodArgs}}
				{{.CLIVar}},
				{{- end}}
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: 		transactionOpts.From,
					To: 		&contractAddress,
					Data: 		transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	{{range .MethodArgs}}
	cmd.Flags().{{.Flag}}
	{{- end}}

	return cmd
}
{{- end}}
`

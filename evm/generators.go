// - [ ] Working CLI generation for deployment, calls, transactions against a contract given its ABI and bytecode.
// - [ ] Generated code has a header comment explaining that code is generated by seer, modify at your own risk, etc.
// - [ ] Generated CLI contains a command to crawl and parse contract events.

package evm

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/iancoleman/strcase"
	"github.com/moonstream-to/seer/version"
	"golang.org/x/tools/imports"
)

// ErrParsingCLISpecification is raised when there is an error producing a CLI specification from AST
// nodes. It indicates that seer's assumptions about the code generated by the go-ethereum Go bindings
// generators are no longer correct.
var ErrParsingCLISpecification error = errors.New("error parsing CLI parameters")

// ErrParameterUnnamed is raised when a method argument is unnamed. go-ethereum's bind.Bind does not
// leave its method arguments unnamed, so this also indicates a skew in seer's assumptions and the actual
// generated code it is using from go-ethereum's bind.Bind.
var ErrParameterUnnamed error = errors.New("parameter is unnamed")

// GenerateTypes generates Go bindings to an Ethereum contract ABI (or union of such). This functionality
// is roughly equivalent to that provided by the `abigen` tool provided by go-ethereum:
// https://github.com/ethereum/go-ethereum/tree/master/cmd/abigen
// Under the hood, GenerateTypes uses the Bind method implemented in go-ethereum in a manner similar to
// abigen. It just offers a simpler call signature that makes more sense for users of seer.
//
// Arguments:
//  1. structName: The name of the generated Go struct that will represent this contract.
//  2. abi: The bytes representing the contract's ABI.
//  3. bytecode: The bytes representing the contract's bytecode. If this is provided, a "deploy" method
//     will be generated. If it is not provided, no such method will be generated.
//  4. packageName: If this is provided, the generated code will contain a package declaration of this name.
//  5. aliases: This is a mapping of aliases for identifiers from an ABI. Necessary because Go bindings have trouble with overloaded methods in an ABI.
func GenerateTypes(structName string, abi []byte, bytecode []byte, packageName string, aliases map[string]string) (string, error) {
	return bind.Bind([]string{structName}, []string{string(abi)}, []string{string(bytecode)}, []map[string]string{}, packageName, bind.LangGo, map[string]string{}, aliases)
}

// ABIBoundParameter represents a Go type that is bound to an Ethereum contract ABI item.
// The different types of types we need to deal with (based on https://github.com/ethereum/go-ethereum/blob/47d76c5f9508d3594bfc9aafa95c04edae71c5a1/accounts/abi/bind/bind.go#L338):
// - uint8
// - uint16
// - uint32
// - uint64
// - int8
// - int16
// - int32
// - int64
// - *big.Int
// - [n]byte
// - []byte
// - string
// - bool
// - array
// - struct
type ABIBoundParameter struct {
	Name     string
	GoType   string
	Node     ast.Node
	IsArray  bool
	Length   int
	Subtypes []ABIBoundParameter
}

// MethodArgument specifies a method argument to a smart contract bound method and how it should be handled
// in the generated CLI.
type MethodArgument struct {
	Argument   ABIBoundParameter
	CLIVar     string
	CLIRawVar  string
	CLIName    string
	CLIType    string
	CLIRawType string
	Flag       string
	PreRunE    string
}

// MethodReturnValue specifies a value returned by a smart contract bound method and how it should be
// handled in the generated CLI.
type MethodReturnValue struct {
	ReturnValue    ABIBoundParameter
	CaptureName    string
	CaptureType    string
	InitializeCode string
	PrintCode      string
}

// HandlerDefinition specifies a (sub)command handler that needs to be generated as part of the CLI.
type HandlerDefinition struct {
	MethodName    string
	HandlerName   string
	MethodArgs    []MethodArgument
	MethodReturns []MethodReturnValue
}

// Data structure that parametrizes CLI generation.
type CLISpecification struct {
	StructName       string
	DeployHandler    HandlerDefinition
	ViewHandlers     []HandlerDefinition
	TransactHandlers []HandlerDefinition
}

// Parameters used to generate header comment for generated code.
type HeaderParameters struct {
	Version     string
	PackageName string
	CLI         bool
	IncludeMain bool
	Foundry     string
	ABI         string
	Bytecode    string
	StructName  string
	OutputFile  string
	NoFormat    bool
}

// Generates the header comment for the generated code.
func GenerateHeader(packageName string, cli bool, includeMain bool, foundry string, abi string, bytecode string, structname string, outputfile string, noformat bool) (string, error) {
	headerTemplate, headerTemplateParseErr := template.New("header").Parse(HeaderTemplate)
	if headerTemplateParseErr != nil {
		return "", headerTemplateParseErr
	}

	parameters := HeaderParameters{
		Version:     version.SeerVersion,
		PackageName: packageName,
		CLI:         cli,
		IncludeMain: includeMain,
		Foundry:     foundry,
		ABI:         abi,
		Bytecode:    bytecode,
		StructName:  structname,
		OutputFile:  outputfile,
		NoFormat:    noformat,
	}

	var b bytes.Buffer
	templateErr := headerTemplate.Execute(&b, parameters)
	if templateErr != nil {
		return "", templateErr
	}

	return b.String(), nil
}

// ParseBoundParameter parses an ast.Node representing a method parameter (or return value). It inspects
// the ast.Node recursively to determine the information needed to parse that node to the user from command-line
// input or to present an instance of that type to a user as command output.
func ParseBoundParameter(arg ast.Node) (ABIBoundParameter, error) {
	result := ABIBoundParameter{Node: arg}

	switch n := arg.(type) {

	// Entrypoint of recursion - highest level of abstraction and we'll never see a field again in subsequent
	// invocations.
	case *ast.Field:
		if len(n.Names) > 0 {
			result.Name = n.Names[0].Name
		}
		subresult, subresultErr := ParseBoundParameter(n.Type)
		if subresultErr != nil {
			return subresult, subresultErr
		}
		result.GoType = subresult.GoType
		result.IsArray = subresult.IsArray
		result.Length = subresult.Length
		result.Subtypes = subresult.Subtypes

	case *ast.ArrayType:
		result.IsArray = true

		// Check if the array is of fixed length. If so, extract the length into the result.Length field.
		if n.Len != nil {
			var conversionErr error
			result.Length, conversionErr = strconv.Atoi(n.Len.(*ast.BasicLit).Value)
			if conversionErr != nil {
				return result, conversionErr
			}
		}

		// Set result.Subtypes to be the type of the array elements.
		result.Subtypes = make([]ABIBoundParameter, 1)
		subtype, subtypeErr := ParseBoundParameter(n.Elt)
		if subtypeErr != nil {
			return result, subtypeErr
		}
		result.Subtypes[0] = subtype

		if result.Length > 0 {
			result.GoType = fmt.Sprintf("[%d]%s", result.Length, subtype.GoType)
		} else {
			result.GoType = fmt.Sprintf("[]%s", subtype.GoType)
		}
	default:
		var b bytes.Buffer
		printer.Fprint(&b, token.NewFileSet(), n)
		result.GoType = b.String()
	}

	return result, nil
}

var byteArrayRegexp *regexp.Regexp = regexp.MustCompile(`\[(?P<len>\d*)\]byte`)
var byteArrayUnwrapRegexp *regexp.Regexp = regexp.MustCompile(`^\[(?P<len>\d*)\]`)

type byteArrayLevel struct {
	Index      int
	TargetType string
	Length     int
	Accessor   string
}

type byteArraySpec struct {
	TargetVar        string
	RawVar           string
	IntermediateVar  string
	IntermediateType string
	Levels           []byteArrayLevel
	FinalType        string
	FinalLength      int
	FinalAccessor    string
	Depth            int
}

func minusOne(i int) int {
	return i - 1
}

// Should be applied to a byteArraySpec
var byteArrayDecoderTemplateDefinition string = `var {{.IntermediateVar}} {{.IntermediateType}}

{{if (eq .Depth 0)}}
var {{.IntermediateVar}}HexDecodeErr error
{{.IntermediateVar}}, {{.IntermediateVar}}HexDecodeErr = hex.DecodeString({{.RawVar}})
if {{.IntermediateVar}}HexDecodeErr != nil {
	return {{.IntermediateVar}}HexDecodeErr
}
{{else}}
unmarshalErr := json.Unmarshal([]byte({{.RawVar}}), &{{.IntermediateVar}})
if unmarshalErr != nil {
	return unmarshalErr
}
{{end}}

{{range .Levels}}
{{if (eq .Index 0)}}
{{$.TargetVar}} = make({{.TargetType}}, len({{$.IntermediateVar}}))
{{if (eq .Index $.Depth)}}
for i{{.Index}}, v{{.Index}} := range {{$.IntermediateVar}} {{ "{" }}
{{else}}
for i{{.Index}}, _ := range {{$.IntermediateVar}} {{ "{" }}
{{end}}
{{else}}
{{$.TargetVar}}{{.Accessor}} = make({{.TargetType}}, len({{$.IntermediateVar}}{{.Accessor}}))
{{if (eq .Index $.Depth)}}
for i{{.Index}}, _ := range v{{(minusOne .Index)}} {{ "{" }}
{{else}}
for i{{.Index}}, v{{.Index}} := range v{{(minusOne .Index)}} {{ "{" }}
{{end}}
{{end}}
{{end}}

copy({{.TargetVar}}{{.FinalAccessor}}[:], {{.IntermediateVar}}{{.FinalAccessor}})

{{range .Levels}}
{{ "}" }}
{{end}}
`

var byteArrayDecoderTemplate *template.Template = template.Must(template.New("byteArrayDecoder").Funcs(map[string]any{"minusOne": minusOne}).Parse(byteArrayDecoderTemplateDefinition))

// Fills in the information required to represent the given parameters as command-line argument. Takes
// an array of ABIBoundParameter structs because it deduplicates flags.
// This is where we map the Go types used in the methods to the Go types used to parse those arguments from the
// command line.
func DeriveMethodArguments(parameters []ABIBoundParameter) ([]MethodArgument, error) {
	result := make([]MethodArgument, len(parameters))

	// assignedNames helps us ensure that there are no collisions in named arguments in our CLI.
	// It contains reserved argument names and is populated with the name of every argument that gets added
	// to a method's CLI.
	assignedNames := map[string]bool{
		"rpc":                  true,
		"keystore":             true,
		"value":                true,
		"gasPrice":             true,
		"nonce":                true,
		"from":                 true,
		"fromAddress":          true,
		"to":                   true,
		"toAddress":            true,
		"block":                true,
		"pending":              true,
		"maxFeePerGas":         true,
		"maxPriorityFeePerGas": true,
		"gasLimit":             true,
		"noSend":               true,
		"timeout":              true,
		"password":             true,
		"contract":             true,
		"method":               true,
		"args":                 true,
		"output":               true,
		"chainId":              true,
		"network":              true,
		"simulate":             true,
		"contractAddress":      true,
		"name":                 true,
	}

	for i, parameter := range parameters {
		result[i].Argument = parameter

		if parameter.Name == "" {
			return result, ErrParameterUnnamed
		}
		j := 0
		name := strings.Trim(parameter.Name, "-_")
		for {
			_, assigned := assignedNames[name]
			if !assigned {
				break
			}
			name = fmt.Sprintf("%s%d", parameter.Name, j)
			j++
		}
		assignedNames[name] = true

		result[i].CLIVar = name
		// If CLIRawVar is different from CLIVar, that is a signal that we need to add parsing logic in
		// PreRunE.
		result[i].CLIRawVar = name
		result[i].CLIType = parameter.GoType
		result[i].CLIRawType = parameter.GoType
		result[i].CLIName = strcase.ToKebab(name)

		// Cases we need to handle
		// - uint8
		// - uint16
		// - uint32
		// - uint64
		// - int8
		// - int16
		// - int32
		// - int64
		// - string
		// - bool
		// - common.Address
		// - *big.Int
		// - anything else (structs, arrays, etc. will be parsed as JSON strings or strings of the form "@<filename>" containing JSON)
		switch parameter.GoType {
		case "uint8":
			result[i].Flag = fmt.Sprintf("Uint8Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "uint16":
			result[i].Flag = fmt.Sprintf("Uint16Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "uint32":
			result[i].Flag = fmt.Sprintf("Uint32Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "uint64":
			result[i].Flag = fmt.Sprintf("Uint64Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int8":
			result[i].Flag = fmt.Sprintf("Int8Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int16":
			result[i].Flag = fmt.Sprintf("Int16Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int32":
			result[i].Flag = fmt.Sprintf("Int32Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "int64":
			result[i].Flag = fmt.Sprintf("Int64Var(&%s, \"%s\", 0, \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
		case "string":
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)

		case "bool":
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument (true, t, y, yes, 1 OR false, f, n, no, 0)\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
			preRunFormat := `
%sLower := strings.ToLower(%s)
switch %sLower {
case "true", "t", "y", "yes", "1":
	%s = true
case "false", "f", "n", "no", "0":
	%s = false
default:
	return fmt.Errorf("--%s argument is not valid (value: %%s)", %s)
}
`
			result[i].PreRunE = fmt.Sprintf(
				preRunFormat,
				result[i].CLIRawVar,
				result[i].CLIRawVar,
				result[i].CLIRawVar,
				result[i].CLIVar,
				result[i].CLIVar,
				result[i].CLIName,
				result[i].CLIRawVar,
			)

		case "*big.Int":
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName)
			preRunEFormat := `
if %s == "" {
	return fmt.Errorf("--%s argument not specified")
}
%s = new(big.Int)
%s.SetString(%s, 0)
`
			result[i].PreRunE = fmt.Sprintf(
				preRunEFormat,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIVar,
				result[i].CLIVar,
				result[i].CLIRawVar,
			)

		case "common.Address":
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"
			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument (%s)\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName, result[i].CLIType)
			preRunEFormat := `
if %s == "" {
	return fmt.Errorf("--%s argument not specified")
} else if !common.IsHexAddress(%s) {
	return fmt.Errorf("--%s argument is not a valid Ethereum address")
}
%s = common.HexToAddress(%s)
`
			result[i].PreRunE = fmt.Sprintf(
				preRunEFormat,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIVar,
				result[i].CLIRawVar,
			)

		// In the default case, we handle the various type of byte arrays slightly separately from other types of lists,
		// structs, etc.
		// This is because we cannot simply use JSON unmarshaling to work with bytes.
		// The case of bytes is only slightly different from the general case, and largely uses the same logic. That is
		// the reason for the peculiar branching structure of the following code. It only differs in the CLIRawType
		// definition, and in some additional parsing code after the default PreRunE snippet.
		default:
			// In any case, we will need a raw variable.
			result[i].CLIRawVar = fmt.Sprintf("%sRaw", result[i].CLIVar)
			result[i].CLIRawType = "string"

			result[i].Flag = fmt.Sprintf("StringVar(&%s, \"%s\", \"\", \"%s argument (%s)\")", result[i].CLIRawVar, result[i].CLIName, result[i].CLIName, result[i].CLIType)
			preRunEFormat := `
if %s == "" {
	return fmt.Errorf("--%s argument not specified")
} else if strings.HasPrefix(%s, "@") {
	filename := strings.TrimPrefix(%s, "@")
	contents, readErr := os.ReadFile(filename)
	if readErr != nil {
		return readErr
	}
	unmarshalErr := json.Unmarshal(contents, &%s)
	if unmarshalErr != nil {
		return unmarshalErr
	}
} else {
	unmarshalErr := json.Unmarshal([]byte(%s), &%s)
	if unmarshalErr != nil {
		return unmarshalErr
	}
}
`

			result[i].PreRunE = fmt.Sprintf(
				preRunEFormat,
				result[i].CLIRawVar,
				result[i].CLIName,
				result[i].CLIRawVar,
				result[i].CLIRawVar,
				result[i].CLIVar,
				result[i].CLIRawVar,
				result[i].CLIVar,
			)

			if strings.HasSuffix(parameter.GoType, "byte") {
				depth := strings.Count(result[i].CLIType, "[")
				if depth > 0 {
					depth--
				}

				matchesWithGroups := byteArrayRegexp.FindStringSubmatch(result[i].CLIType)
				lenIndex := byteArrayRegexp.SubexpIndex("len")
				lenRaw := matchesWithGroups[lenIndex]
				finalLength := 0
				if lenRaw != "" {
					var convErr error
					finalLength, convErr = strconv.Atoi(lenRaw)
					if convErr != nil {
						return result, convErr
					}
				}

				finalType := "[]byte"
				if finalLength > 0 {
					finalType = fmt.Sprintf("[%d]byte", finalLength)
				}

				intermediateType := result[i].CLIType
				if finalLength > 0 {
					intermediateType = strings.ReplaceAll(result[i].CLIType, fmt.Sprintf("[%d]byte", finalLength), "[]byte")
				}
				spec := byteArraySpec{
					TargetVar:        result[i].CLIVar,
					RawVar:           result[i].CLIRawVar,
					IntermediateVar:  fmt.Sprintf("%sIntermediate", result[i].CLIVar),
					IntermediateType: intermediateType,
					Levels:           make([]byteArrayLevel, depth),
					FinalLength:      finalLength,
					FinalType:        finalType,
					Depth:            depth,
				}

				currentType := result[i].CLIType
				currentAccessor := ""
				for i := 0; i < depth; i++ {
					levelSpec := byteArrayLevel{
						Index:      i,
						TargetType: currentType,
						Accessor:   currentAccessor,
					}

					unwrapMatchesWithGroups := byteArrayUnwrapRegexp.FindStringSubmatch(currentType)
					unwrapLenIndex := byteArrayUnwrapRegexp.SubexpIndex("len")
					unwrapLenRaw := unwrapMatchesWithGroups[unwrapLenIndex]
					unwrapLength := 0
					if unwrapLenRaw != "" {
						var convErr error
						unwrapLength, convErr = strconv.Atoi(unwrapLenRaw)
						if convErr != nil {
							return result, convErr
						}
					}

					levelSpec.Length = unwrapLength

					spec.Levels[i] = levelSpec
					currentAccessor = fmt.Sprintf("%s[i%d]", currentAccessor, i)
					currentType = byteArrayUnwrapRegexp.ReplaceAllString(currentType, "")
				}

				spec.FinalAccessor = currentAccessor

				var additionalCode bytes.Buffer
				byteArrayDecoderTemplateErr := byteArrayDecoderTemplate.Execute(&additionalCode, spec)
				if byteArrayDecoderTemplateErr != nil {
					return result, byteArrayDecoderTemplateErr
				}

				if result[i].CLIRawType == "string" {
					result[i].PreRunE = additionalCode.String()
				} else {
					result[i].PreRunE = result[i].PreRunE + "\n" + additionalCode.String()
				}
			}
		}
	}

	return result, nil
}

// Fills in the information required to present the given return values to the user as output from a CLI.
func DeriveMethodReturnValues(parameters []ABIBoundParameter) ([]MethodReturnValue, error) {
	result := make([]MethodReturnValue, len(parameters))

	for i, parameter := range parameters {
		result[i].ReturnValue = parameter
		result[i].CaptureName = fmt.Sprintf("capture%d", i)
		result[i].CaptureType = parameter.GoType
		result[i].InitializeCode = fmt.Sprintf("var %s %s", result[i].CaptureName, result[i].CaptureType)

		switch parameter.GoType {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
			result[i].PrintCode = fmt.Sprintf("cmd.Printf(\"%d: %%d\\n\", %s)", i, result[i].CaptureName)

		case "string":
			result[i].PrintCode = fmt.Sprintf("cmd.Printf(\"%d: %%s\\n\", %s)", i, result[i].CaptureName)

		case "*big.Int":
			result[i].PrintCode = fmt.Sprintf("cmd.Printf(\"%d: %%s\\n\", %s.String())", i, result[i].CaptureName)

		case "common.Address":
			result[i].PrintCode = fmt.Sprintf("cmd.Printf(\"%d: %%s\\n\", %s.Hex())", i, result[i].CaptureName)

		case "bool":
			result[i].PrintCode = fmt.Sprintf("cmd.Printf(\"%d: %%t\\n\", %s)", i, result[i].CaptureName)

		default:
			result[i].PrintCode = fmt.Sprintf("cmd.Printf(\"%d: %%v\\n\", %s)", i, result[i].CaptureName)
		}
	}

	return result, nil
}

// Produces a CLI specification for the structure with the given name, provided the AST nodes representing
// the deployment method, the transaction methods, and the view methods for the corresponding smart contract.
//
// The value of the deployMethod argument is used to determine if the deployment functionality will be
// added to the CLI. If deployMethod is nil, then a deployment command is not generated. This is signified
// by the result.DeployHandler.MethodName being empty in the resulting CLISpecification.
func ParseCLISpecification(structName string, deployMethod *ast.FuncDecl, viewMethods map[string]*ast.FuncDecl, transactMethods map[string]*ast.FuncDecl) (CLISpecification, error) {
	result := CLISpecification{StructName: structName}

	result.DeployHandler = HandlerDefinition{
		HandlerName: fmt.Sprintf("Create%sDeploymentCommand", structName),
	}
	if deployMethod != nil {
		result.DeployHandler.MethodName = deployMethod.Name.Name

		// Deploy methods always take the following two arguments at the beginning of their argument list:
		// - auth *bind.TransactOpts
		// - backend bind.ContractBackend
		// We ignore these arguments here because they can all be handled uniformly when we run codegen for the
		// deployment command.
		if len(deployMethod.Type.Params.List) < 2 {
			return result, ErrParsingCLISpecification
		}
		parameters := make([]ABIBoundParameter, len(deployMethod.Type.Params.List)-2)
		for i, arg := range deployMethod.Type.Params.List[2:] {
			parameter, parameterErr := ParseBoundParameter(arg)
			if parameterErr != nil {
				return result, parameterErr
			}
			parameters[i] = parameter
		}

		methodArgs, methodArgsErr := DeriveMethodArguments(parameters)
		if methodArgsErr != nil {
			return result, methodArgsErr
		}
		result.DeployHandler.MethodArgs = methodArgs
	}

	result.ViewHandlers = make([]HandlerDefinition, len(viewMethods))
	currentViewHandler := 0

	viewMethodNames := make([]string, 0, len(viewMethods))
	for viewMethodName := range viewMethods {
		viewMethodNames = append(viewMethodNames, viewMethodName)
	}
	sort.Strings(viewMethodNames)

	for _, methodName := range viewMethodNames {
		methodNode := viewMethods[methodName]
		parameters := make([]ABIBoundParameter, len(methodNode.Type.Params.List))

		// Every view method, when bound to Go, will retrun an error as its last return value.
		returnParameters := make([]ABIBoundParameter, len(methodNode.Type.Results.List)-1)

		for i, arg := range methodNode.Type.Params.List {
			parameter, parameterErr := ParseBoundParameter(arg)
			if parameterErr != nil {
				return result, parameterErr
			}
			parameters[i] = parameter
		}

		methodArgs, methodArgsErr := DeriveMethodArguments(parameters)
		if methodArgsErr != nil {
			return result, methodArgsErr
		}

		for i, val := range methodNode.Type.Results.List[:len(methodNode.Type.Results.List)-1] {
			returnParam, returnParamErr := ParseBoundParameter(val)
			if returnParamErr != nil {
				return result, returnParamErr
			}
			returnParameters[i] = returnParam
		}

		methodReturns, methodReturnsErr := DeriveMethodReturnValues(returnParameters)
		if methodReturnsErr != nil {
			return result, methodReturnsErr
		}

		handler := HandlerDefinition{
			MethodName:    methodName,
			HandlerName:   fmt.Sprintf("Create%sCommand", strcase.ToCamel(methodName)),
			MethodArgs:    methodArgs,
			MethodReturns: methodReturns,
		}

		result.ViewHandlers[currentViewHandler] = handler
		currentViewHandler++
	}

	result.TransactHandlers = make([]HandlerDefinition, len(transactMethods))
	currentTransactHandler := 0

	transactMethodNames := make([]string, 0, len(transactMethods))
	for transactMethodName := range transactMethods {
		transactMethodNames = append(transactMethodNames, transactMethodName)
	}
	sort.Strings(transactMethodNames)

	for _, methodName := range transactMethodNames {
		methodNode := transactMethods[methodName]
		parameters := make([]ABIBoundParameter, len(methodNode.Type.Params.List))
		for i, arg := range methodNode.Type.Params.List {
			parameter, parameterErr := ParseBoundParameter(arg)
			if parameterErr != nil {
				return result, parameterErr
			}
			parameters[i] = parameter
		}

		methodArgs, methodArgsErr := DeriveMethodArguments(parameters)
		if methodArgsErr != nil {
			return result, methodArgsErr
		}

		handler := HandlerDefinition{
			MethodName:  methodName,
			HandlerName: fmt.Sprintf("Create%sCommand", strcase.ToCamel(methodName)),
			MethodArgs:  methodArgs,
		}

		result.TransactHandlers[currentTransactHandler] = handler
		currentTransactHandler++
	}

	return result, nil
}

// AddCLI adds CLI code (using github.com/spf13/cobra command-line framework) for code generated by the
// GenerateTypes function. The output of this function *contains* the input, with enrichments (some of
// then inline). It should not be concatenated with the output of GenerateTypes, but rather be used as
// part of a chain.
func AddCLI(sourceCode, structName string, noformat, includemain bool) (string, error) {
	fileset := token.NewFileSet()
	filename := ""
	sourceAST, sourceASTErr := parser.ParseFile(fileset, filename, sourceCode, parser.ParseComments)
	if sourceASTErr != nil {
		return "", sourceASTErr
	}

	deployer := fmt.Sprintf("Deploy%s", structName)
	callerReceiver := fmt.Sprintf("%sCallerSession", structName)
	transactorReceiver := fmt.Sprintf("%sTransactorSession", structName)

	var deployMethod *ast.FuncDecl
	structViewMethods := map[string]*ast.FuncDecl{}
	structTransactionMethods := map[string]*ast.FuncDecl{}

	ast.Inspect(sourceAST, func(node ast.Node) bool {
		switch t := node.(type) {
		case *ast.GenDecl:
			// Add additional imports:
			// - context
			// - encoding/hex
			// - encoding/json
			// - fmt
			// - os
			// - time
			// - github.com/spf13/cobra
			// - github.com/ethereum/go-ethereum/accounts/keystore
			// - github.com/ethereum/go-ethereum/ethclient
			// - golang.org/x/term
			// - github.com/moonstream-to/seer/bindings/GnosisSafe
			// - github.com/moonstream-to/seer/bindings/CreateCall
			// - github.com/ethereum/go-ethereum/common/math
			// - github.com/ethereum/go-ethereum/crypto
			if t.Tok == token.IMPORT {
				t.Specs = append(
					t.Specs,
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"context"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"encoding/hex"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"encoding/json"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"fmt"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"os"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"time"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/spf13/cobra"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/ethereum/go-ethereum/accounts/keystore"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/ethereum/go-ethereum/ethclient"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"golang.org/x/term"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/moonstream-to/seer/bindings/GnosisSafe"`}},
					&ast.ImportSpec{Path: &ast.BasicLit{Value: `"github.com/moonstream-to/seer/bindings/CreateCall"`}},
				)
			}
			return true
		case *ast.FuncDecl:
			if t.Recv != nil {
				receiverName := t.Recv.List[0].Type.(*ast.StarExpr).X.(*ast.Ident).Name
				if receiverName == callerReceiver {
					structViewMethods[t.Name.Name] = t
				} else if receiverName == transactorReceiver {
					structTransactionMethods[t.Name.Name] = t
				}
			} else {
				if t.Name.Name == deployer {
					deployMethod = t
				}
			}
			return false
		default:
			return true
		}
	})

	var codeBytes bytes.Buffer
	printer.Fprint(&codeBytes, fileset, sourceAST)
	code := codeBytes.String()

	templateFuncs := map[string]any{
		"KebabCase":      strcase.ToKebab,
		"ScreamingSnake": strcase.ToScreamingSnake,
		"ToLowerCamel":   strcase.ToLowerCamel,
	}

	cliTemplate, cliTemplateParseErr := template.New("cli").Funcs(templateFuncs).Parse(CLICodeTemplate)
	if cliTemplateParseErr != nil {
		return code, cliTemplateParseErr
	}

	deployCommandTemplate, deployCommandTemplateErr := template.New("deploy").Funcs(templateFuncs).Parse(DeployCommandTemplate)
	if deployCommandTemplateErr != nil {
		return code, deployCommandTemplateErr
	}

	viewMethodsCommandsTemplate, viewMethodsCommandsTemplateErr := template.New("viewMethods").Funcs(templateFuncs).Parse(ViewMethodCommandsTemplate)
	if viewMethodsCommandsTemplateErr != nil {
		return code, viewMethodsCommandsTemplateErr
	}

	transactionMethodsCommandsTemplate, transactionMethodsCommandsTemplateErr := template.New("transactionMethods").Funcs(templateFuncs).Parse(TransactMethodCommandsTemplate)
	if transactionMethodsCommandsTemplateErr != nil {
		return code, transactionMethodsCommandsTemplateErr
	}

	cliSpec, cliSpecErr := ParseCLISpecification(structName, deployMethod, structViewMethods, structTransactionMethods)
	if cliSpecErr != nil {
		return code, cliSpecErr
	}

	var b bytes.Buffer

	deployTemplateErr := deployCommandTemplate.Execute(&b, cliSpec)
	if deployTemplateErr != nil {
		return code, deployTemplateErr
	}
	code = code + "\n\n" + b.String()

	b.Reset()
	viewMethodsTemplateErr := viewMethodsCommandsTemplate.Execute(&b, cliSpec)
	if viewMethodsTemplateErr != nil {
		return code, viewMethodsTemplateErr
	}
	code = code + "\n\n" + b.String()

	b.Reset()
	transactionMethodsTemplateErr := transactionMethodsCommandsTemplate.Execute(&b, cliSpec)
	if transactionMethodsTemplateErr != nil {
		return code, transactionMethodsTemplateErr
	}
	code = code + "\n\n" + b.String()

	b.Reset()
	cliTemplateErr := cliTemplate.Execute(&b, cliSpec)
	if cliTemplateErr != nil {
		return code, cliTemplateErr
	}
	code = code + "\n\n" + b.String()

	if includemain {
		mainFormatString := `func main() {
	command := %s()
	err := command.Execute()
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}
`
		mainCode := fmt.Sprintf(mainFormatString, fmt.Sprintf("Create%sCommand", structName))
		code = code + "\n\n" + mainCode
	}

	if !noformat {
		// We use golang.org/x/tools/imports instead of go/format.
		// imports.Process does what format.Source does AND it removes unused imports.
		opts := &imports.Options{
			Fragment:   false,
			AllErrors:  true,
			Comments:   true,
			FormatOnly: false,
		}
		generatedCode, formattingErr := imports.Process("mem", []byte(code), opts)
		if formattingErr != nil {
			return code, formattingErr
		}

		code = string(generatedCode)
	}
	return code, nil
}

// This template is used to generate the skeleton of the CLI, along with all utility methods that can be
// used by CLI handlers. It is expected to be applied to a CLISpecification struct.
var CLICodeTemplate string = `
var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the {{(ScreamingSnake .StructName)}}_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the {{(ScreamingSnake .StructName)}}_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("{{(ScreamingSnake .StructName)}}_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func Create{{.StructName}}Command() *cobra.Command {
	cmd := &cobra.Command{
		Use:  "{{(KebabCase .StructName)}}",
		Short: "Interact with the {{.StructName}} contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	{{if .DeployHandler.MethodName}}
	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	{{- end}}
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	{{if .DeployHandler.MethodName}}
	cmd{{.DeployHandler.MethodName}} := {{.DeployHandler.HandlerName}}()
	cmd{{.DeployHandler.MethodName}}.GroupID = DeployGroup.ID
	cmd.AddCommand(cmd{{.DeployHandler.MethodName}})
	{{- end}}

	{{range .ViewHandlers}}
	cmdView{{.MethodName}} := {{.HandlerName}}()
	cmdView{{.MethodName}}.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdView{{.MethodName}})
	{{- end}}

	{{range .TransactHandlers}}
	cmdTransact{{.MethodName}} := {{.HandlerName}}()
	cmdTransact{{.MethodName}}.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransact{{.MethodName}})
	{{- end}}

	return cmd
}

// SafeOperationType represents the type of operation for a Safe transaction
type SafeOperationType uint8

const (
	Call         SafeOperationType = 0
	DelegateCall SafeOperationType = 1
)

// String returns the string representation of the SafeOperationType
func (o SafeOperationType) String() string {
	switch o {
	case Call:
		return "Call"
	case DelegateCall:
		return "DelegateCall"
	default:
		return "Unknown"
	}
}

// SafeTransactionData represents the data for a Safe transaction
type SafeTransactionData struct {
	To             string        ` + "`" + `json:"to"` + "`" + `
	Value          string        ` + "`" + `json:"value"` + "`" + `
	Data           string        ` + "`" + `json:"data"` + "`" + `
	Operation      SafeOperationType ` + "`" + `json:"operation"` + "`" + `
	SafeTxGas      uint64        ` + "`" + `json:"safeTxGas"` + "`" + `
	BaseGas        uint64        ` + "`" + `json:"baseGas"` + "`" + `
	GasPrice       string        ` + "`" + `json:"gasPrice"` + "`" + `
	GasToken       string        ` + "`" + `json:"gasToken"` + "`" + `
	RefundReceiver string        ` + "`" + `json:"refundReceiver"` + "`" + `
	Nonce          uint64        ` + "`" + `json:"nonce"` + "`" + `
	SafeTxHash     string        ` + "`" + `json:"safeTxHash"` + "`" + `
	Sender         string        ` + "`" + `json:"sender"` + "`" + `
	Signature      string        ` + "`" + `json:"signature"` + "`" + `
	Origin         string        ` + "`" + `json:"origin"` + "`" + `
}

const (
	NativeTokenAddress = "0x0000000000000000000000000000000000000000"
)


func DeployWithSafe(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, factoryAddress common.Address, value *big.Int, txServiceBaseUrl string, deployBytecode []byte, safeOperationType SafeOperationType) error {
	// Generate salt
	salt, err := GenerateProperSalt(safeAddress)
	if err != nil {
		return fmt.Errorf("failed to generate salt: %v", err)
	}

	abi, err := CreateCall.CreateCallMetaData.GetAbi()
	if err != nil {
		return fmt.Errorf("failed to get ABI: %v", err)
	}

	safeCreateCallTxData, err := abi.Pack("performCreate2", value, deployBytecode, salt)
	if err != nil {
		return fmt.Errorf("failed to pack performCreate2 transaction: %v", err)
	}

	return CreateSafeProposal(client, key, safeAddress, factoryAddress, safeCreateCallTxData, value, txServiceBaseUrl, SafeOperationType(safeOperationType))
}

func GenerateProperSalt(from common.Address) ([32]byte, error) {
	var salt [32]byte

	// Copy the 'from' address to the first 20 bytes of the salt
	copy(salt[:20], from[:])

	// Generate random bytes for the remaining 12 bytes
	_, err := rand.Read(salt[20:])
	if err != nil {
		return [32]byte{}, fmt.Errorf("failed to generate random bytes: %w", err)
	}

	return salt, nil
}

func CreateSafeProposal(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, to common.Address, data []byte, value *big.Int, txServiceBaseUrl string, safeOperationType SafeOperationType) error {
	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get chain ID: %v", err)
	}

	// Create a new instance of the GnosisSafe contract
	safeInstance, err := GnosisSafe.NewGnosisSafe(safeAddress, client)
	if err != nil {
		return fmt.Errorf("failed to create GnosisSafe instance: %v", err)
	}

	// Fetch the current nonce from the Safe contract
	nonce, err := safeInstance.Nonce(&bind.CallOpts{})
	if err != nil {
		return fmt.Errorf("failed to fetch nonce from Safe contract: %v", err)
	}

	safeTransactionData := SafeTransactionData{
		To:             to.Hex(),
		Value:          value.String(),
		Data:           common.Bytes2Hex(data),
		Operation:      safeOperationType,
		SafeTxGas:      0,
		BaseGas:        0,
		GasPrice:       "0",
		GasToken:       NativeTokenAddress,
		RefundReceiver: NativeTokenAddress, 
		Nonce:          nonce.Uint64(),
	}

	// Calculate SafeTxHash
	safeTxHash, err := CalculateSafeTxHash(safeAddress, safeTransactionData, chainID)
	if err != nil {
		return fmt.Errorf("failed to calculate SafeTxHash: %v", err)
	}

	// Sign the SafeTxHash
	signature, err := crypto.Sign(safeTxHash.Bytes(), key.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to sign SafeTxHash: %v", err)
	}

	// Adjust V value for Ethereum's replay protection
	signature[64] += 27

	// Convert signature to hex
	senderSignature := "0x" + common.Bytes2Hex(signature)

	// Prepare the request body
	requestBody := map[string]interface{}{
		"to":             safeTransactionData.To,
		"value":          safeTransactionData.Value,
		"data":           "0x" + safeTransactionData.Data,
		"operation":      int(safeTransactionData.Operation),
		"safeTxGas":      fmt.Sprintf("%d", safeTransactionData.SafeTxGas),
		"baseGas":        fmt.Sprintf("%d", safeTransactionData.BaseGas),
		"gasPrice":       safeTransactionData.GasPrice,
		"gasToken":       safeTransactionData.GasToken,
		"refundReceiver": safeTransactionData.RefundReceiver,
		"nonce":          fmt.Sprintf("%d", safeTransactionData.Nonce),
		"safeTxHash":     safeTxHash.Hex(),
		"sender":         key.Address.Hex(),
		"signature":      senderSignature,
		"origin":         fmt.Sprintf("{\"url\":\"%s\",\"name\":\"TokenSender Deployment\"}", txServiceBaseUrl),
	}

	// Marshal the request body to JSON
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %v", err)
	}

	// Send the request to the Safe Transaction Service
	req, err := http.NewRequest("POST", txServiceBaseUrl, bytes.NewBuffer(jsonBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	httpClient := &http.Client{}
	resp, err := httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	fmt.Println("Safe proposal created successfully")
	return nil
}

func CalculateSafeTxHash(safeAddress common.Address, txData SafeTransactionData, chainID *big.Int) (common.Hash, error) {
	domainSeparator := apitypes.TypedDataDomain{
		ChainId:           (*math.HexOrDecimal256)(chainID),
		VerifyingContract: safeAddress.Hex(),
	}

	typedData := apitypes.TypedData{
		Types: apitypes.Types{
			"EIP712Domain": []apitypes.Type{
				{Name: "chainId", Type: "uint256"},
				{Name: "verifyingContract", Type: "address"},
			},
			"SafeTx": []apitypes.Type{
				{Name: "to", Type: "address"},
				{Name: "value", Type: "uint256"},
				{Name: "data", Type: "bytes"},
				{Name: "operation", Type: "uint8"},
				{Name: "safeTxGas", Type: "uint256"},
				{Name: "baseGas", Type: "uint256"},
				{Name: "gasPrice", Type: "uint256"},
				{Name: "gasToken", Type: "address"},
				{Name: "refundReceiver", Type: "address"},
				{Name: "nonce", Type: "uint256"},
			},
		},
		Domain:      domainSeparator,
		PrimaryType: "SafeTx",
		Message: apitypes.TypedDataMessage{
			"to":             txData.To,
			"value":          txData.Value,
			"data":           "0x" + txData.Data,
			"operation":      fmt.Sprintf("%d", txData.Operation),
			"safeTxGas":      fmt.Sprintf("%d", txData.SafeTxGas),
			"baseGas":        fmt.Sprintf("%d", txData.BaseGas),
			"gasPrice":       txData.GasPrice,
			"gasToken":       txData.GasToken,
			"refundReceiver": txData.RefundReceiver,
			"nonce":          fmt.Sprintf("%d", txData.Nonce),
		},
	}

	typedDataHash, _, err := apitypes.TypedDataAndHash(typedData)
	if err != nil {
		return common.Hash{}, fmt.Errorf("failed to hash typed data: %v", err)
	}

	return common.BytesToHash(typedDataHash), nil
}
`

// This template generates the handler for smart contract deployment. It is intended to be used with a
// CLISpecification struct.
var DeployCommandTemplate string = `
{{if .DeployHandler.MethodName}}
func {{.DeployHandler.HandlerName}}() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var safeAddress, safeApi, safeCreateCall string
	var safeOperationType uint8
	{{range .DeployHandler.MethodArgs}}
	var {{.CLIVar}} {{.CLIType}}
	{{if (ne .CLIRawVar .CLIVar)}}var {{.CLIRawVar}} {{.CLIRawType}}{{end}}
	{{- end}}

	cmd := &cobra.Command{
		Use:  "deploy",
		Short: "Deploy a new {{.StructName}} contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if safeCreateCall == "" {
					fmt.Println("--safe-create-call not specified, using default (0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4)")
					safeCreateCall = "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
				}
				if !common.IsHexAddress(safeCreateCall) {
					return fmt.Errorf("--safe-create-call is not a valid Ethereum address")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			{{range .DeployHandler.MethodArgs}}
			{{.PreRunE}}
			{{- end}}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			if safeAddress != "" {
				// Generate deploy bytecode with constructor arguments
				deployBytecode, err := generate{{.StructName}}DeployBytecode(
					{{- range .DeployHandler.MethodArgs}}
					{{.CLIVar}},
					{{- end}}
				)
				if err != nil {
					return fmt.Errorf("failed to generate deploy bytecode: %v", err)
				}

				// Create Safe proposal for deployment
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = DeployWithSafe(client, key, common.HexToAddress(safeAddress), common.HexToAddress(safeCreateCall), value, safeApi, deployBytecode, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			address, deploymentTransaction, _, deploymentErr := {{.DeployHandler.MethodName}}(
				transactionOpts,
				client,
				{{- range .DeployHandler.MethodArgs}}
				{{.CLIVar}},
				{{- end}}
			)
			if deploymentErr != nil {
				return deploymentErr
			}


			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: 		transactionOpts.From,
					Data: 		deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().StringVar(&safeCreateCall, "safe-create-call", "", "Address of the CreateCall contract (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 1, "Safe operation type: 0 (Call) or 1 (DelegateCall) - default is 1")
	
	{{range .DeployHandler.MethodArgs}}
	cmd.Flags().{{.Flag}}
	{{- end}}

	return cmd
}

func generate{{.StructName}}DeployBytecode(
	{{- range .DeployHandler.MethodArgs}}
	{{.CLIVar}} {{.CLIType}},
	{{- end}}
) ([]byte, error) {
	abiPacked, err := {{.StructName}}MetaData.GetAbi()
	if err != nil {
		return nil, fmt.Errorf("failed to get ABI: %v", err)
	}

	constructorArguments, err := abiPacked.Pack("",
		{{- range .DeployHandler.MethodArgs}}
		{{.CLIVar}},
		{{- end}}
	)
	if err != nil {
		return nil, fmt.Errorf("failed to pack constructor arguments: %v", err)
	}

	deployBytecode := append(common.FromHex({{.StructName}}MetaData.Bin), constructorArguments...)
	return deployBytecode, nil
}
{{end}}
`

// This template generates the handlers for all smart contract call methods. It is intended to be used
// with a CLISpecification struct.
var ViewMethodCommandsTemplate string = `{{$structName := .StructName}}
{{range .ViewHandlers}}
func {{.HandlerName}}() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	{{range .MethodArgs}}
	var {{.CLIVar}} {{.CLIType}}
	{{if (ne .CLIRawVar .CLIVar)}}var {{.CLIRawVar}} {{.CLIRawType}}{{end}}
	{{- end}}

	{{range .MethodReturns}}
	{{.InitializeCode}}
	{{- end}}

	cmd := &cobra.Command{
		Use: "{{(KebabCase .MethodName)}}",
		Short: "Call the {{.MethodName}} view method on a {{$structName}} contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			{{range .MethodArgs}}
			{{.PreRunE}}
			{{- end}}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := New{{$structName}}(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := {{$structName}}CallerSession{
				Contract: &contract.{{$structName}}Caller,
				CallOpts: callOpts,
			}

			var callErr error
			{{range .MethodReturns}}{{.CaptureName}}, {{end}}callErr = session.{{.MethodName}}(
				{{- range .MethodArgs}}
				{{.CLIVar}},
				{{- end}}
			)
			if callErr != nil {
				return callErr
			}

			{{range .MethodReturns}}
			{{.PrintCode}}
			{{- end}}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	{{range .MethodArgs}}
	cmd.Flags().{{.Flag}}
	{{- end}}

	return cmd
}
{{- end}}
`

// This template generates the handlers for all smart contract methods that submit transactions. It
// is intended to be used with a CLISpecification struct.
var TransactMethodCommandsTemplate string = `{{$structName := .StructName}}
{{range .TransactHandlers}}
func {{.HandlerName}}() *cobra.Command {
    var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
    var gasLimit uint64
    var simulate bool
    var timeout uint
    var contractAddress common.Address
    var safeAddress, safeApi string
	var safeOperationType uint8

    {{range .MethodArgs}}
    var {{.CLIVar}} {{.CLIType}}
    {{if (ne .CLIRawVar .CLIVar)}}var {{.CLIRawVar}} {{.CLIRawType}}{{end}}
    {{- end}}

    cmd := &cobra.Command{
        Use: "{{(KebabCase .MethodName)}}",
        Short: "Execute the {{.MethodName}} method on a {{$structName}} contract",
        PreRunE: func(cmd *cobra.Command, args []string) error {
            if contractAddressRaw == "" {
                return fmt.Errorf("--contract not specified")
            } else if !common.IsHexAddress(contractAddressRaw) {
                return fmt.Errorf("--contract is not a valid Ethereum address")
            }
            contractAddress = common.HexToAddress(contractAddressRaw)

            if keyfile == "" {
                return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
            }

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

            if safeAddress != "" {
                if !common.IsHexAddress(safeAddress) {
                    return fmt.Errorf("--safe is not a valid Ethereum address")
                }
                if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
            }

            {{range .MethodArgs}}
            {{.PreRunE}}
            {{- end}}

            return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
            client, clientErr := NewClient(rpc)
            if clientErr != nil {
                return clientErr
            }

            key, keyErr := KeyFromFile(keyfile, password)
            if keyErr != nil {
                return keyErr
            }

            chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
            defer cancelChainIDCtx()
            chainID, chainIDErr := client.ChainID(chainIDCtx)
            if chainIDErr != nil {
                return chainIDErr
            }

            transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
            if transactionOptsErr != nil {
                return transactionOptsErr
            }

            SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

            contract, contractErr := New{{$structName}}(contractAddress, client)
            if contractErr != nil {
                return contractErr
            }

            session := {{$structName}}TransactorSession{
                Contract: &contract.{{$structName}}Transactor,
                TransactOpts: *transactionOpts,
            }

            if safeAddress != "" {
                // Generate transaction data
				abi, err := {{$structName}}MetaData.GetAbi()
                if err != nil {
                    return fmt.Errorf("failed to get ABI: %v", err)
                }
				// TODO: this is a workaround to match the original method name in the ABI, need to fix to work with every method name
                packedData, err := abi.Pack("{{ToLowerCamel .MethodName}}",
                    {{range .MethodArgs}}
                    {{.CLIVar}},
                    {{- end}}
                )
                if err != nil {
                    return fmt.Errorf("failed to pack transaction data: %v", err)
                }

                // Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
                err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, packedData, value, safeApi, SafeOperationType(safeOperationType))
                if err != nil {
                    return fmt.Errorf("failed to create Safe proposal: %v", err)
                }

                return nil
            }

            transaction, err := session.{{.MethodName}}(
                {{range .MethodArgs}}
                {{.CLIVar}},
                {{- end}}
            )
            if err != nil {
                return err
            }

            cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
            if transactionOpts.NoSend {
                estimationMessage := ethereum.CallMsg{
                    From: 		transactionOpts.From,
					To: 		&contractAddress,
                    Data: 		transaction.Data(),
                }

                gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
                defer cancelGasEstimationCtx()

                gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
                if gasEstimateErr != nil {
                    return gasEstimateErr
                }

                transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
                if transactionBinaryErr != nil {
                    return transactionBinaryErr
                }
                transactionBinaryHex := hex.EncodeToString(transactionBinary)

                cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
            } else {
                cmd.Println("Transaction submitted")
            }

            return nil
        },
    }

    cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
    cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
    cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
    cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
    cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
    cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
    cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
    cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
    cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
    cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
    cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
    cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
    cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

    {{range .MethodArgs}}
    cmd.Flags().{{.Flag}}
    {{- end}}

    return cmd
}
{{- end}}
`

// This is the Go template used to create header information at the top of the generated code.
// At a bare minimum, the header specifies the version of seer that was used to generate the code.
// This template should be applied to a EVMHeaderParameters struct.
var HeaderTemplate string = `// This file was generated by seer: https://github.com/moonstream-to/seer.
// seer version: {{.Version}}
// seer command: seer evm generate{{if .PackageName}} --package {{.PackageName}}{{end}}{{if .CLI}} --cli{{end}}{{if .IncludeMain}} --includemain{{end}}{{if (ne .Foundry "")}} --foundry {{.Foundry}}{{end}}{{if (ne .ABI "")}} --abi {{.ABI}}{{end}}{{if (ne .Bytecode "")}} --bytecode {{.Bytecode}}{{end}} --struct {{.StructName}}{{if (ne .OutputFile "")}} --output {{.OutputFile}}{{end}}{{if .NoFormat}} --noformat{{end}}
`
